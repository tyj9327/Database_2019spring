options{  static = true;  DEBUG_PARSER = false;  IGNORE_CASE = true;  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(SimpleDBMSParser)import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.io.UnsupportedEncodingException;import java.util.*;import com.sleepycat.je.Database;import com.sleepycat.je.DatabaseException;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.DatabaseEntry;import com.sleepycat.je.Cursor;import com.sleepycat.je.OperationStatus;import com.sleepycat.je.LockMode;import com.sleepycat.je.DatabaseConfig;import com.sleepycat.je.Environment;import com.sleepycat.je.EnvironmentConfig;import parsingTools.*;import myDBMSTools.*;public class SimpleDBMSParser implements Serializable{  	/**	 * 	 */  private static final long serialVersionUID = 201212506L;  public static final int PRINT_SYNTAX_ERROR = 0;  public static final int PRINT_CREATE_TABLE = 1;  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC_TABLE = 3;  public static final int PRINT_SHOW_TABLE = 4;  public static final int PRINT_SELECT_TABLE = 5;  public static final int PRINT_INSERT_TABLE = 6;  public static final int PRINT_DELETE_TABLE = 7;    public static void main(String args[]) throws ParseException  {    Environment tableDBenv = null;    Database tableDB = null;    Database tupleDB = null;try{		  // Open Database Environment or if not, create one.		  EnvironmentConfig tableEnvConfig = new EnvironmentConfig();		  tableEnvConfig.setAllowCreate(true);	      tableDBenv = new Environment(new File("db/"), tableEnvConfig);	      	  		      //Open Database or if not, create one.	      DatabaseConfig tableDBConfig = new DatabaseConfig();	      DatabaseConfig tupleDBConfig = new DatabaseConfig();	      tableDBConfig.setAllowCreate(true);	      tableDBConfig.setSortedDuplicates(true);	      tupleDBConfig.setAllowCreate(true);	      tupleDBConfig.setSortedDuplicates(true);	      tableDB = tableDBenv.openDatabase(null, "tableDB", tableDBConfig);	      tupleDB = tableDBenv.openDatabase(null, "tupleDB", tupleDBConfig);	     	  }	    catch (DatabaseException dbe){			System.err.println("Error accessing database." + dbe);	    }
	        SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    System.out.print("DB_2012-12506> ");	// 데이터베이스를 닫아주는 시점을 조절;	boolean exit = false;    while (!exit)    {      try      {        exit = parser.command(tableDB, tupleDB);      }      catch (Exception e)      {//        e.printStackTrace();        printMessage(PRINT_SYNTAX_ERROR);        SimpleDBMSParser.ReInit(System.in);      }    }		if(tableDB != null) tableDB.close();	if(tupleDB != null) tupleDB.close();    if(tableDBenv != null) tableDBenv.close();	System.exit(0);  }  // calls descTableDB method from DBmanage classpublic static void descTableDB(String tableName, Database tableDB) {		try {		DBmanage.descTableDB(tableName, tableDB);	} catch (myTableException e) {		// TODO Auto-generated catch block		e.printStackTrace();	} catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}	}  // calls createTableDB method from DBmanage classpublic static void createTableDB(String tableName, ArrayList<String > tElementList, Database tableDB, Database tupleDB) {	try {		DBmanage.createTableDB(tableName, tableDB, tupleDB, tElementList);	} catch (myTableException e) {		// TODO Auto-generated catch block		e.printStackTrace();	} catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}}  // calls showTableDB method from DBmanage classpublic static void showTableDB(Database tableDB) {	try {		DBmanage.showDB(tableDB);	} catch (myTableException e) {		// TODO Auto-generated catch block		e.printStackTrace();	}}  // calls dropTableDB method from DBmanage classpublic static void dropTableDB(String tableName, Database tableDB, Database tupleDB) {	try {		DBmanage.dropTableDB(tableName, tableDB, tupleDB);	} catch (myTableException e) {		// TODO Auto-generated catch block		e.printStackTrace();	} catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}}//public static void insertToTable(Database tableDB, Database tupleDB, String tableName, ArrayList<ArrayList<String>> insertingRows) throws Exception, myTableException {public static void insertTableDB(String tableName, Database tableDB, Database tupleDB, ArrayList<ArrayList<String>> insertingRows) {	try {		DBmanage.insertToTable(tableDB, tupleDB, tableName, insertingRows);	} catch (myTableException e) {		// TODO Auto-generated catch block		e.printStackTrace();	} catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}}//public static void selectTableDB(String tableName, Database tableDB, Database tupleDB, TableExpression tExp, ArrayList<String> selectList) {public static void selectTableDB(Database tableDB, Database tupleDB, TableExpression TE, ArrayList<String> selectList) {	  try {
		DBmanage.selectTableDB(tableDB, tupleDB, TE, selectList);
	}catch (myTableException mte) {	  	mte.printStackTrace();	}catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}//public static void deleteRowDB(Database tableDB, Database tupleDB, String tableName, WhereClause WC) throws myTableException, Exception
public static void deleteRowTableDB(Database tableDB, Database tupleDB, String tableName, WhereClause WC) {  	try {  	  DBmanage.deleteRowDB(tableDB, tupleDB, tableName, WC);  	} catch (myTableException mte) {	  	mte.printStackTrace();	}catch (Exception e) {		// TODO Auto-generated catch block		e.printStackTrace();	}}  public static void printMessage(int q)  {    switch(q)    {      case PRINT_SYNTAX_ERROR:      	System.out.println("Syntax error");      	break;      case PRINT_CREATE_TABLE://      	System.out.println("\'CREATE TABLE\' requested");      	break;      case PRINT_DROP_TABLE://      	System.out.println("\'DROP TABLE\' requested");      	break;      case PRINT_DESC_TABLE://      	System.out.println("\'DESC\' requested");      	break;      case PRINT_SHOW_TABLE://      	System.out.println("\'SHOW_TABLE\' requested");      	break;      case PRINT_SELECT_TABLE://      	System.out.println("\'SELECT\' requested");      	break;      case PRINT_INSERT_TABLE://    	System.out.println("\'INSERT\' requested");      	break;      case PRINT_DELETE_TABLE://      	System.out.println("\'DELETE\' requested");      	break;    }    System.out.print("DB_2012-12506> ");  }}PARSER_END(SimpleDBMSParser)SKIP : { " " | "\r" | "\t" | "\n" }//token에 추가된 keywords들은 legal identifier로 사용되지 않게 됨.TOKEN : /* Keywords */{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < TABLE : "table" >| < TABLES : "tables" >| < DROP : "drop" >| < DESC : "desc" >| < SELECT : "select" >| < INSERT : "insert" >| < DELETE : "delete" >| < SHOW : "show" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < ASTERISK : "*" > // select에서 * 선택하는 경우 토큰 추가| < AS : "as" > | < FROM : "from" > | < WHERE : "where" >| < OR : "or" >| < NOT : "not">| < AND : "and" >| < IS : "is" >| < NULL : "null" > | < INTO : "into" >| < VALUES : "values" >}TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < UNDERSCORE : "_" >| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>| < SIGN : "+" | "-" >| < DIGIT : [ "0"-"9" ] >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < PERIOD : "." > //select에서 . 선택하는 경우 토큰 추가| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >| < QUOTE_IN : "'" > : STATE1| < CHAR_STRING : < QUOTE_IN > (< NON_QUOTE_CHARACTER >)* < QUOTE_OUT > >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > > | < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >}/*   1. QUOTE token 뒤에 오는 space는 skip하지 않고 하나의 token으로 인식해야하므로 새로운 state를 정의해서   	  QUOTE_IN을 인식하면 STATE1으로 진입해서 space를 인식하게 됨. 이후 다시 QUOTE_OUT을 만나면 DEFAULT로 복귀.   2. NON_QUOTE_SPECIAL_CHARACTERS 와 NON_QUOTE_CHARACTER 의 경우 QUOTE token을 통해 STATE1으로 들어온 뒤에      인식되어야 하므로 STATE1 token에 입력.*/< STATE1 > TOKEN :{  < SPACE : " " >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-" | "{" | "}" | "[" | "]" | "~" |	"`" | "+" | "*" | "_" | "=" | "\\" | "(" | ")" | "<" | ">" | "?" | "," | "." | "\n" | "\t" | "\r" | ":" | ";" | "|" | "/"> | < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | < SPACE > >| < QUOTE_OUT : "'" > : DEFAULT
}// exit을 하게 되면 DB를 닫을 수 있도록 boolean을 returnboolean command(Database tDB, Database tupleDB) :{}{  (      queryList(tDB, tupleDB)  )  {    return false;  }    | (    < EXIT >    < SEMICOLON >    {      return true;    }  ) }void queryList(Database tDB, Database tupleDB) :{  int q;}{  (    q = query(tDB, tupleDB)    {      printMessage(q);    }  )+}int query(Database tDB, Database tupleDB) :{  int q;}{  (    createTableQuery(tDB, tupleDB)    {      q = PRINT_CREATE_TABLE;    }|   	dropTableQuery(tDB, tupleDB) // table drop  	{  	  q = PRINT_DROP_TABLE;  	}|   	describeQuery(tDB) // describe table  	{  	  q = PRINT_DESC_TABLE;  	}|   	selectQuery(tDB, tupleDB) // select  	{  	  q = PRINT_SELECT_TABLE;  	}|   	insertQuery(tDB, tupleDB) // insert  	{  	  q = PRINT_INSERT_TABLE;  	}|   	deleteQuery(tDB, tupleDB) //delete  	{  	  q = PRINT_DELETE_TABLE;  	}|   	showTableQuery(tDB) //show table  	{  	  q = PRINT_SHOW_TABLE;  	} )  (    {      return q;    }  )}void createTableQuery(Database tDB, Database tupleDB) :{  String tName;  ArrayList<String > tElementList;}{  < CREATE >  < TABLE >  tName = tableName()  tElementList = tableElementList()  < SEMICOLON >  {    createTableDB(tName, tElementList, tDB, tupleDB);  }}void dropTableQuery(Database tDB, Database tupleDB) :{  String tName;}{  < DROP > < TABLE >  tName = tableName()  < SEMICOLON >  {    dropTableDB(tName, tDB, tupleDB);  }}void describeQuery(Database tDB) :{  String tName;}{  < DESC >  tName = tableName()  < SEMICOLON >  {    descTableDB(tName, tDB);  }}void showTableQuery(Database tDB) :{}{  < SHOW > < TABLES > < SEMICOLON >  {    showTableDB(tDB);  }}void insertQuery(Database tDB, Database tupleDB) :
{	String tName;	ArrayList<ArrayList<String >> rows;}
{
  < INSERT > < INTO >  tName = tableName()  rows = insertColumnsAndSource()  < SEMICOLON >  {    insertTableDB(tName, tDB, tupleDB, rows); 
  }
}
void deleteQuery(Database tableDB, Database tupleDB) :
{
  String fromTable;
  WhereClause WC = null;  ArrayList<String> fromList = new ArrayList<String>();

}
{
  < DELETE > < FROM >
  fromTable = tableName()  {    fromList.add(fromTable);
  }
  (
    WC = whereClause(fromList, tableDB, tupleDB)
  )?
  < SEMICOLON >
  {
		deleteRowTableDB(tableDB, tupleDB, fromTable, WC);
  }
}
//CREATE_TABLE  // tableElement를 arraylist로 반환;ArrayList<String > tableElementList() :{  ArrayList<String > tElementList = new ArrayList<String >();  String tElement;}{  < LEFT_PAREN >  tElement = tableElement()  {    tElementList.add(tElement);  }  ( < COMMA >  tElement = tableElement()  {    tElementList.add(tElement);  }  )*  < RIGHT_PAREN >  {    return tElementList;  }}String tableElement() :{  String columnDef;  String constDef;}{  columnDef = columnDefinition()  {    return columnDef;  }  |  constDef = tableConstraintDefinition()  {    return constDef;  }}// not null이 constraints로 있거나, 아예 없는 경우 포함.String columnDefinition() :{  String cName;  String dType;  String isNull = "Y";  String columnDef;  }{  cName = columnName()  dType = dataType()  ( < NOT > < NULL >  {    isNull = "N";  }  )?  {    columnDef = "#ColumnDef" + "@" + cName + "@" + dType + "@" + isNull;    return columnDef;  }}String tableConstraintDefinition() :{  String pKey;  String refKey;}{  pKey = primaryKeyConstraint()  {    return pKey;  }  |  refKey = referentialConstraint()  {    return refKey;  }}String primaryKeyConstraint() :{  String primaryColumnNameList;}{  < PRIMARY > < KEY >  primaryColumnNameList = columnNameList()  {    return "#Primary" + primaryColumnNameList;  }}String referentialConstraint() :{  String foreignColumnList;  String refTableName;  String refColumnList;}{  < FOREIGN > < KEY >  foreignColumnList = columnNameList()  < REFERENCES >  refTableName = tableName()  refColumnList = columnNameList()  {    //이부분 어떻게 split할지 고민. refColumnList 역시 space로 split해야 하기 때문에..    return "#Foreign" + foreignColumnList + "@#Reference@" + refTableName + refColumnList;  }}// 여러 개의 columnName이 COMMA로 연결될 수 있음.// Split하는 방법 고민!String columnNameList() :{  String cNameList = "";  String columnName;}{  < LEFT_PAREN >  columnName = columnName()  {    cNameList += "@" + columnName;  }  ( < COMMA >  columnName = columnName()  {    cNameList += "@" + columnName;  }  )*  < RIGHT_PAREN >  {    return cNameList;  }}String dataType() :{  Token intVal;}{  < INT >  {    return "int";  }  |   ( < CHAR > < LEFT_PAREN >  intVal = < INT_VALUE >  < RIGHT_PAREN >  {    return "char(" + intVal.image + ")";  }  )  | < DATE >  {    return "date";  }}String tableName() :{  Token legIdentifier;}{  legIdentifier = < LEGAL_IDENTIFIER >  {    return legIdentifier.image.toLowerCase();  }}String columnName() :{  Token legIdentifier;}{  legIdentifier = < LEGAL_IDENTIFIER >  {    return legIdentifier.image.toLowerCase();  }}//SELECT_TABLEvoid selectQuery(Database tableDB, Database tupleDB) :{  TableExpression TE;  ArrayList<String> selList;  ArrayList<ArrayList<String>> finalChosenRows;}{  < SELECT >  selList = selectList()  TE = tableExpression(tableDB, tupleDB)  < SEMICOLON >  {        // 여기에 dbSelect 추가!    selectTableDB(tableDB, tupleDB, TE, selList);  }}ArrayList<String> selectList() :{  ArrayList<String> selColumnList = new ArrayList<String>();  String selColumn = "";}{  (	  < ASTERISK >	  {	    selColumnList.add("*");	  }	| selColumn = selectedColumn()	  {	    selColumnList.add(selColumn);	  }	  (	    < COMMA >	    selColumn = selectedColumn()	    {	      selColumnList.add(selColumn);	    }	  )*  )  {    return selColumnList;  }}/* tableName()과 columnName() 두 함수 모두 LEGAL_IDENTIFIER를 token으로 사용하기 때문에   이 둘을 구분지어줄 필요가 있음. 이를 위해  LOOKAHEAD를 사용하여 2개의 token을 무조건 확인하도록 하면   < PERIOD >가 발견되면 tablename. 이 포함된 것으로 인식하도록 할 수 있음.*/String selectedColumn() : // tName#cName@cName or tName#cName or cName or cName@cName{  String tName;  String cName;  String selColumn = "";}{  ( LOOKAHEAD(2)  	tName = tableName()  	< PERIOD >	  	{	  	  selColumn += tName + ".";	  	}  )?  	cName = columnName()  	{  	  selColumn += cName;  	}  (    < AS >  	cName = columnName()  	{  	  selColumn += "@" + cName;  	}  )?  {    return selColumn;  }}    TableExpression tableExpression(Database tableDB, Database tupleDB) :{  TableExpression TE;  WhereClause WC = null;  ArrayList<String> fromList; //<tName, tName, ... >}{  fromList = fromClause()  (    WC = whereClause(fromList, tableDB, tupleDB)  )?  {    TE = new TableExpression(WC, fromList);    return TE;  }}// 이부분을 BooleanDefiner로 보내주어야 함! predicate 부분에서 사용 ArrayList<String> fromClause() :{  ArrayList<String> tNameList;}{  < FROM >  tNameList = tableReferenceList()  {    return tNameList;  }}ArrayList<String> tableReferenceList() :{  ArrayList<String> tNameList = new ArrayList<String>();  String tName;}{  tName = referedTable()  {    tNameList.add(tName);  }  (    < COMMA >    tName = referedTable()    {      tNameList.add(tName);    }  )*  {    return tNameList;  }}String referedTable() :{  String tName = "";  String rename = "";}{  tName = tableName()  (    < AS >    rename = tableName()    {      rename = "#" + rename;    }  )?  {    return tName + rename; // tName#rename  }}// 체크할 부분 WhereClause whereClause(ArrayList<String> fromTableList, Database tableDB, Database tupleDB) :{  ArrayList<ArrayList<String>> finalMatchingRows;  WhereClause WC;  ArrayList<ArrayList<String>> joinedRows = DBmanage.makingJoinedRows(tableDB, tupleDB, fromTableList); // 전부 join한 tuple들   ArrayList<String> columnNameList = DBmanage.getColumnNameList(tableDB, fromTableList); // 모든 조인된 튜플의 column 이름 list ( table 여러개면 tName.cName으로 저장)  ArrayList<String> dataTypeList = DBmanage.getDataTypeList(tableDB, fromTableList); // 모든 조인된 칼럼의 dataType list  String[] matchingRowsIndex;  }{  < WHERE >  matchingRowsIndex = booleanValueExpression(joinedRows, columnNameList, dataTypeList)  {    finalMatchingRows = BooleanDefiner.getFinalRows(matchingRowsIndex, joinedRows);   	WC = new WhereClause(finalMatchingRows, columnNameList);    return WC;  }}String[] booleanValueExpression(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> columnNameList, ArrayList<String> dataTypeList) :{  String[] matchingRowsIndex;  ArrayList<String[]> boolTermList = new ArrayList<String[]>();  String[] boolTerm;}{  boolTerm = booleanTerm(joinedRows, columnNameList, dataTypeList)  {    boolTermList.add(boolTerm);  }  (    < OR >    boolTerm = booleanTerm(joinedRows, columnNameList, dataTypeList)    {      boolTermList.add(boolTerm);    }  )*  {    matchingRowsIndex = BooleanDefiner.afterOrMatchingRows(boolTermList);    return matchingRowsIndex;  }}String[] booleanTerm(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> columnNameList, ArrayList<String> dataTypeList) :{  ArrayList<String[]> boolFactorList = new ArrayList<String[]>();  String[] boolFactor;  String[] matchingRowsIndex;}{  boolFactor = booleanFactor(joinedRows, columnNameList, dataTypeList)  {    boolFactorList.add(boolFactor);  }  (    < AND >    boolFactor = booleanFactor(joinedRows, columnNameList, dataTypeList)    {      boolFactorList.add(boolFactor);    }  )*  {    matchingRowsIndex = BooleanDefiner.afterAndMatchingRows(boolFactorList);    return matchingRowsIndex;  } }String[] booleanFactor(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> columnNameList, ArrayList<String> dataTypeList) :{  String[] matchingRowsIndex;  String[] bTestIndex;  String not = "";}{  (    < NOT >    {      not += "not";    }  )?   bTestIndex = booleanTest(joinedRows, columnNameList, dataTypeList)  {    matchingRowsIndex = BooleanDefiner.afterNotMatchingRows(bTestIndex, not);    return matchingRowsIndex;  }}String[] booleanTest(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> columnNameList, ArrayList<String> dataTypeList) :{  String[] matchingRowsIndex;  }{  (   	matchingRowsIndex = predicate(joinedRows, columnNameList, dataTypeList)    |    matchingRowsIndex = parenthesizedBooleanExpression(joinedRows, columnNameList, dataTypeList)  )  {    return matchingRowsIndex;  }}String[] parenthesizedBooleanExpression(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> joinedColumnNames, ArrayList<String> dataTypeList) :{  String[] matchingRowsIndex;}{  < LEFT_PAREN >  matchingRowsIndex = booleanValueExpression(joinedRows, joinedColumnNames, dataTypeList)  < RIGHT_PAREN >  {    return matchingRowsIndex;  }}/* nullPredicate()함수와 comparisonPredicate()함수 둘 모두 내부적으로   ( LOOKAHEAD(2) tableName() < PERIOD > )? columnName() 라는 중복된 부분을 확인하게 됨.   이 때문에 둘을 구분지어줄 수 있는 LOOKAHEAD가 필요하며, nullPredicate()함수 전체의 token 길이만큼   체크하여 nullPredicate()에 해당하는지 확인 - nullOperation()함수 부분의 유무 check - 한 후,   해당사항에 없으면 comparisonPredicate()으로 인식할 수 있도록 LOOKAHEAD(nullPredicate())를 사용했음.*/String[] predicate(ArrayList<ArrayList<String>> joinedRows, ArrayList<String> joinedColumnNames, ArrayList<String> dataTypeList) :{  String predicateLine;  String[] matchingRowsIndex;}{  (       LOOKAHEAD(nullPredicate())   predicateLine = nullPredicate() |   predicateLine = comparisonPredicate() ) {	// predicateDefiner(ArrayList<String> dataTypeList, ArrayList<String> joinedColumnNames, ArrayList<ArrayList<String>> joinedRows, String predicateLine, Database tableDB)   matchingRowsIndex = BooleanDefiner.predicateDefiner(dataTypeList, joinedColumnNames, joinedRows, predicateLine);   return matchingRowsIndex;
 }
}// compOperand&<=&compOperand 형태로 나옴!String comparisonPredicate() : {  Token operator;  String op1;  String op2;  String full;}{  op1 = compOperand()  operator = < COMP_OP >  op2 = compOperand()  {    full = op1 + "&" + operator.image + "&" + op2;    return full;  }}/* tableName()과 columnName() 모두 LEGAL_IDENTIFIER를 token으로 가지기 때문에 LOOKAHEAD를 사용하여   PERIOD token의 존재를 확인하여 둘을 구분지음.   comparableValue의 경우 맨 앞에 I, C, D 중 하나로 나오고, 테이블이 포함된 칼럼이 나오게 되면 맨 앞에 T가, 그냥 칼럼이 나오면 @가 나옴.   1) I.../C.../D... 2)TtName.@cName 3)@cName */String compOperand() : // TtName.@cName 이거나, comparableValue만 나오거나. 구분은 맨 앞 T 혹은 @로. {  String compOp = "";  String tName;  String cName;  }{  (	  compOp = comparableValue() // I, C, D중 하나로 시작. 	| (	    LOOKAHEAD(2)	    tName = tableName()	    < PERIOD >	    {	      compOp = tName + ".";	    }	  )?	    cName = columnName()	    {	      compOp += "@" + cName;	    }  )  {    return compOp;  }    }String comparableValue() :{  Token value;}{  value = < INT_VALUE >  {    return "I" + value.image;  }  	// < CHAR_STRING : < QUOTE_IN > (< NON_QUOTE_CHARACTER >)* < QUOTE_OUT > >| value = < CHAR_STRING >  {    return "C" + value.image.substring(1, value.image.length() - 1).toLowerCase();  }| value = < DATE_VALUE >  {    return "D" + value.image;  }}/* tableName()과 columnName() 모두 LEGAL_IDENTIFIER를 token으로 가지기 때문에 LOOKAHEAD를 사용하여   PERIOD token의 존재를 확인하여 둘을 구분지음. */String nullPredicate() : // $tName#cName@isnotnull 또는 $cName@isnotnull{  String nullString = "";  String tName;  String cName;  String nullOp;}{  ( LOOKAHEAD(2)  	tName = tableName() < PERIOD >  	{  	  nullString += tName + "#";  	}  )?  cName = columnName()  {    nullString += cName + "@";  }  nullOp = nullOperation()  {    nullString += nullOp;    nullString = "$" + nullString;    return nullString;  }}/* create table 쿼리에서 NOT_NULL token을 이미 만들어두었기 때문에 NULL token을 따로 추가하여 둘 중 하나로 인식.*/String nullOperation() : //isnull or isnotnull 반환 
{  String nullOp = "";}
{
  < IS >  {    nullOp += "is";
  }  (    < NOT >    {      nullOp += "not";    }  )? < NULL >  {    nullOp += "null";    return nullOp;
  }
}

//InsertPart

ArrayList<ArrayList<String >> insertColumnsAndSource() :
{  ArrayList<String> vList;  String cNameList = "";}
{
  ( cNameList = columnNameList() )?  vList = valueList() //ArrayList<String >  {    ArrayList<ArrayList<String >> rows = new ArrayList<ArrayList<String >>();    if(cNameList.equals("")) {      rows.add(vList);      return rows;    }else {      ArrayList<String> columnNames = new ArrayList<String >();      String[] columnNamesArr = cNameList.substring(1).split("@");      for(String cName : columnNamesArr) {        columnNames.add(cName);      }      rows.add(vList);      rows.add(columnNames);      return rows;    }
  }
}
ArrayList<String> valueList() :
{  ArrayList<String> vList = new ArrayList<String>();  String values;}
{
  < VALUES > < LEFT_PAREN >  values = value()  {    vList.add(values);  }  ( < COMMA >  	values = value()  	{  	  vList.add(values);  	}  )*  < RIGHT_PAREN >  {    return vList;  }}String value() :{  String values;}{  < NULL >  {    return "null";  }  |  values = comparableValue()  {    return values;  }}